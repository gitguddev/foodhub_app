{"version":3,"sources":["Smartphone_Frame.svg","MobileApp.png","PreviewLanding.svg","../node_modules/qr-scanner/src/qr-scanner.js","../node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js","route/Landing.js"],"names":["module","exports","QrScanner","video","onDecode","canvasSizeOrOnDecodeError","this","_onDecodeError","bind","canvasSize","DEFAULT_CANVAS_SIZE","preferredFacingMode","$video","$canvas","document","createElement","_onDecode","_preferredFacingMode","_active","_paused","_flashOn","console","warn","width","height","_sourceRect","x","y","_updateSourceRect","_onPlay","_onVisibilityChange","playsInline","muted","disablePictureInPicture","addEventListener","_qrEnginePromise","createQrEngine","navigator","mediaDevices","enumerateDevices","then","devices","some","device","kind","catch","Promise","resolve","window","track","srcObject","getVideoTracks","ImageCapture","getPhotoCapabilities","result","fillLightMode","includes","error","reject","_setFlash","removeEventListener","stop","_postWorkerMessage","location","protocol","hidden","clearTimeout","_offTimeout","play","facingMode","_getCameraStream","stream","_getFacingMode","_setVideoMirror","e","pause","setTimeout","o","Symbol","iterator","Array","isArray","unsupportedIterableToArray","i","F","s","n","length","done","value","_e","f","TypeError","it","err","normalCompletion","didErr","step","next","_e2","getTracks","red","green","blue","useIntegerApproximation","inversionMode","_scanFrame","start","smallestDimension","Math","min","videoWidth","videoHeight","sourceRectSize","round","paused","ended","requestAnimationFrame","readyState","qrEngine","scanImage","message","indexOf","NO_QR_CODE_FOUND","log","exact","constraintsToTry","forEach","constraint","_getMatchingCameraStream","getUserMedia","shift","on","hasFlash","applyConstraints","advanced","torch","scaleFactor","style","transform","videoStream","videoTrack","test","label","imageOrFileOrUrl","sourceRect","canvas","fixedCanvasSize","alsoTryWithoutSourceRect","gotExternalWorker","Worker","promise","all","_loadImage","canvasContext","engine","image","_drawToCanvas","postMessage","type","data","timeout","onMessage","onError","event","errorMessage","imageData","getImageData","buffer","detect","scanResults","rawValue","finally","workerPath","WORKER_PATH","BarcodeDetector","getSupportedFormats","supportedFormats","formats","sourceRectX","sourceRectY","sourceRectWidth","sourceRectHeight","context","getContext","alpha","imageSmoothingEnabled","drawImage","imageOrFileOrBlobOrUrl","HTMLCanvasElement","HTMLVideoElement","ImageBitmap","OffscreenCanvas","Image","_awaitImageLoad","File","Blob","URL","src","createObjectURL","revokeObjectURL","onLoad","complete","naturalWidth","qrEngineOrQrEnginePromise","ScaleUp","keyframes","ContainerStyled","styled","div","Footer","About","Button","button","props","color","PromotionContainer","Detail","span","Title","LandingImg","img","SmallText","Container","videoRef","useRef","useState","scanner","scanning","scanningSet","useEffect","sc","current","href","destroy","gridRow","ref","LandingPreview","alt","position","onClick","disabled","icon","faQrcode","fontSize","to","faStore","faHeart","target","Landing"],"mappings":"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","file":"static/js/10.3d8e8010.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/Smartphone_Frame.e19d4582.svg\";","module.exports = __webpack_public_path__ + \"static/media/MobileApp.88542799.png\";","module.exports = __webpack_public_path__ + \"static/media/PreviewLanding.306e31e5.svg\";","export default class QrScanner {\n    /* async */\n    static hasCamera() {\n        if (!navigator.mediaDevices) return Promise.resolve(false);\n        // note that enumerateDevices can always be called and does not prompt the user for permission. However, device\n        // labels are only readable if served via https and an active media stream exists or permanent permission is\n        // given. That doesn't matter for us though as we don't require labels.\n        return navigator.mediaDevices.enumerateDevices()\n            .then(devices => devices.some(device => device.kind === 'videoinput'))\n            .catch(() => false);\n    }\n\n    constructor(\n        video,\n        onDecode,\n        canvasSizeOrOnDecodeError = this._onDecodeError.bind(this),\n        canvasSize = QrScanner.DEFAULT_CANVAS_SIZE,\n        preferredFacingMode = 'environment'\n    ) {\n        this.$video = video;\n        this.$canvas = document.createElement('canvas');\n        this._onDecode = onDecode;\n        this._preferredFacingMode = preferredFacingMode;\n        this._active = false;\n        this._paused = false;\n        this._flashOn = false;\n\n        if (typeof canvasSizeOrOnDecodeError === 'number') {\n            // legacy function signature where canvas size is the third argument\n            canvasSize = canvasSizeOrOnDecodeError;\n            console.warn('You\\'re using a deprecated version of the QrScanner constructor which will be removed in '\n                + 'the future');\n        } else {\n            this._onDecodeError = canvasSizeOrOnDecodeError;\n        }\n\n        this.$canvas.width = canvasSize;\n        this.$canvas.height = canvasSize;\n        this._sourceRect = {\n            x: 0,\n            y: 0,\n            width: canvasSize,\n            height: canvasSize\n        };\n\n        this._updateSourceRect = this._updateSourceRect.bind(this);\n        this._onPlay = this._onPlay.bind(this);\n        this._onVisibilityChange = this._onVisibilityChange.bind(this);\n\n        // Allow inline playback on iPhone instead of requiring full screen playback,\n        // see https://webkit.org/blog/6784/new-video-policies-for-ios/\n        this.$video.playsInline = true;\n        // Allow play() on iPhone without requiring a user gesture. Should not really be needed as camera stream\n        // includes no audio, but just to be safe.\n        this.$video.muted = true;\n        this.$video.disablePictureInPicture = true;\n        this.$video.addEventListener('loadedmetadata', this._updateSourceRect);\n        this.$video.addEventListener('play', this._onPlay);\n        document.addEventListener('visibilitychange', this._onVisibilityChange);\n\n        this._qrEnginePromise = QrScanner.createQrEngine();\n    }\n\n    /* async */\n    hasFlash() {\n        if (!('ImageCapture' in window)) {\n            return Promise.resolve(false);\n        }\n\n        const track = this.$video.srcObject ? this.$video.srcObject.getVideoTracks()[0] : null;\n        if (!track) {\n            return Promise.reject('Camera not started or not available');\n        }\n\n        const imageCapture = new ImageCapture(track);\n        return imageCapture.getPhotoCapabilities()\n            .then((result) => {\n                return result.fillLightMode.includes('flash');\n            })\n            .catch((error) => {\n                console.warn(error);\n                return false;\n            });\n    }\n\n    isFlashOn() {\n      return this._flashOn;\n    }\n\n    /* async */\n    toggleFlash() {\n      return this._setFlash(!this._flashOn);\n    }\n\n    /* async */\n    turnFlashOff() {\n      return this._setFlash(false);\n    }\n\n    /* async */\n    turnFlashOn() {\n      return this._setFlash(true);\n    }\n\n    destroy() {\n        this.$video.removeEventListener('loadedmetadata', this._updateSourceRect);\n        this.$video.removeEventListener('play', this._onPlay);\n        document.removeEventListener('visibilitychange', this._onVisibilityChange);\n\n        this.stop();\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'close');\n    }\n\n    /* async */\n    start() {\n        if (this._active && !this._paused) {\n            return Promise.resolve();\n        }\n        if (window.location.protocol !== 'https:') {\n            // warn but try starting the camera anyways\n            console.warn('The camera stream is only accessible if the page is transferred via https.');\n        }\n        this._active = true;\n        this._paused = false;\n        if (document.hidden) {\n            // camera will be started as soon as tab is in foreground\n            return Promise.resolve();\n        }\n        clearTimeout(this._offTimeout);\n        this._offTimeout = null;\n        if (this.$video.srcObject) {\n            // camera stream already/still set\n            this.$video.play();\n            return Promise.resolve();\n        }\n\n        let facingMode = this._preferredFacingMode;\n        return this._getCameraStream(facingMode, true)\n            .catch(() => {\n                // We (probably) don't have a camera of the requested facing mode\n                facingMode = facingMode === 'environment' ? 'user' : 'environment';\n                return this._getCameraStream(); // throws if camera is not accessible (e.g. due to not https)\n            })\n            .then(stream => {\n                // Try to determine the facing mode from the stream, otherwise use our guess. Note that the guess is not\n                // always accurate as Safari returns cameras of different facing mode, even for exact constraints.\n                facingMode = this._getFacingMode(stream) || facingMode;\n                this.$video.srcObject = stream;\n                this.$video.play();\n                this._setVideoMirror(facingMode);\n            })\n            .catch(e => {\n                this._active = false;\n                throw e;\n            });\n    }\n\n    stop() {\n        this.pause();\n        this._active = false;\n    }\n\n    pause() {\n        this._paused = true;\n        if (!this._active) {\n            return;\n        }\n        this.$video.pause();\n        if (this._offTimeout) {\n            return;\n        }\n        this._offTimeout = setTimeout(() => {\n            const tracks = this.$video.srcObject ? this.$video.srcObject.getTracks() : [];\n            for (const track of tracks) {\n                track.stop(); //  note that this will also automatically turn the flashlight off\n            }\n            this.$video.srcObject = null;\n            this._offTimeout = null;\n        }, 300);\n    }\n\n    /* async */\n    static scanImage(imageOrFileOrUrl, sourceRect=null, qrEngine=null, canvas=null, fixedCanvasSize=false,\n                     alsoTryWithoutSourceRect=false) {\n        const gotExternalWorker = qrEngine instanceof Worker;\n\n        let promise = Promise.all([\n            qrEngine || QrScanner.createQrEngine(),\n            QrScanner._loadImage(imageOrFileOrUrl),\n        ]).then(([engine, image]) => {\n            qrEngine = engine;\n            let canvasContext;\n            [canvas, canvasContext] = this._drawToCanvas(image, sourceRect, canvas, fixedCanvasSize);\n\n            if (qrEngine instanceof Worker) {\n                if (!gotExternalWorker) {\n                    // Enable scanning of inverted color qr codes. Not using _postWorkerMessage as it's async\n                    qrEngine.postMessage({ type: 'inversionMode', data: 'both' });\n                }\n                return new Promise((resolve, reject) => {\n                    let timeout, onMessage, onError;\n                    onMessage = event => {\n                        if (event.data.type !== 'qrResult') {\n                            return;\n                        }\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        if (event.data.data !== null) {\n                            resolve(event.data.data);\n                        } else {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        }\n                    };\n                    onError = (e) => {\n                        qrEngine.removeEventListener('message', onMessage);\n                        qrEngine.removeEventListener('error', onError);\n                        clearTimeout(timeout);\n                        const errorMessage = !e ? 'Unknown Error' : (e.message || e);\n                        reject('Scanner error: ' + errorMessage);\n                    };\n                    qrEngine.addEventListener('message', onMessage);\n                    qrEngine.addEventListener('error', onError);\n                    timeout = setTimeout(() => onError('timeout'), 10000);\n                    const imageData = canvasContext.getImageData(0, 0, canvas.width, canvas.height);\n                    qrEngine.postMessage({\n                        type: 'decode',\n                        data: imageData\n                    }, [imageData.data.buffer]);\n                });\n            } else {\n                return new Promise((resolve, reject) => {\n                    const timeout = setTimeout(() => reject('Scanner error: timeout'), 10000);\n                    qrEngine.detect(canvas).then(scanResults => {\n                        if (!scanResults.length) {\n                            reject(QrScanner.NO_QR_CODE_FOUND);\n                        } else {\n                            resolve(scanResults[0].rawValue);\n                        }\n                    }).catch((e) => reject('Scanner error: ' + (e.message || e))).finally(() => clearTimeout(timeout));\n                });\n            }\n        });\n\n        if (sourceRect && alsoTryWithoutSourceRect) {\n            promise = promise.catch(() => QrScanner.scanImage(imageOrFileOrUrl, null, qrEngine, canvas, fixedCanvasSize));\n        }\n\n        promise = promise.finally(() => {\n            if (gotExternalWorker) return;\n            QrScanner._postWorkerMessage(qrEngine, 'close');\n        });\n\n        return promise;\n    }\n\n    setGrayscaleWeights(red, green, blue, useIntegerApproximation = true) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations work also\n        // well with colored qr codes.\n        QrScanner._postWorkerMessage(\n            this._qrEnginePromise,\n            'grayscaleWeights',\n            { red, green, blue, useIntegerApproximation }\n        );\n    }\n\n    setInversionMode(inversionMode) {\n        // Note that for the native BarcodeDecoder, this is a no-op. However, the native implementations scan normal\n        // and inverted qr codes by default\n        QrScanner._postWorkerMessage(this._qrEnginePromise, 'inversionMode', inversionMode);\n    }\n\n    /* async */\n    static createQrEngine(workerPath = QrScanner.WORKER_PATH) {\n        return ('BarcodeDetector' in window ? BarcodeDetector.getSupportedFormats() : Promise.resolve([]))\n            .then((supportedFormats) => supportedFormats.indexOf('qr_code') !== -1\n                ? new BarcodeDetector({ formats: ['qr_code'] })\n                : new Worker(workerPath)\n            );\n    }\n\n    _onPlay() {\n        this._updateSourceRect();\n        this._scanFrame();\n    }\n\n    _onVisibilityChange() {\n        if (document.hidden) {\n            this.pause();\n        } else if (this._active) {\n            this.start();\n        }\n    }\n\n    _updateSourceRect() {\n        const smallestDimension = Math.min(this.$video.videoWidth, this.$video.videoHeight);\n        const sourceRectSize = Math.round(2 / 3 * smallestDimension);\n        this._sourceRect.width = this._sourceRect.height = sourceRectSize;\n        this._sourceRect.x = (this.$video.videoWidth - sourceRectSize) / 2;\n        this._sourceRect.y = (this.$video.videoHeight - sourceRectSize) / 2;\n    }\n\n    _scanFrame() {\n        if (!this._active || this.$video.paused || this.$video.ended) return false;\n        // using requestAnimationFrame to avoid scanning if tab is in background\n        requestAnimationFrame(() => {\n            if (this.$video.readyState <= 1) {\n                // Skip scans until the video is ready as drawImage() only works correctly on a video with readyState\n                // > 1, see https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage#Notes.\n                // This also avoids false positives for videos paused after a successful scan which remains visible on\n                // the canvas until the video is started again and ready.\n                this._scanFrame();\n                return;\n            }\n            this._qrEnginePromise\n                .then((qrEngine) => QrScanner.scanImage(this.$video, this._sourceRect, qrEngine, this.$canvas, true))\n                .then(this._onDecode, (error) => {\n                    if (!this._active) return;\n                    const errorMessage = error.message || error;\n                    if (errorMessage.indexOf('service unavailable') !== -1) {\n                        // When the native BarcodeDetector crashed, create a new one\n                        this._qrEnginePromise = QrScanner.createQrEngine();\n                    }\n                    this._onDecodeError(error);\n                })\n                .then(() => this._scanFrame());\n        });\n    }\n\n    _onDecodeError(error) {\n        // default error handler; can be overwritten in the constructor\n        if (error === QrScanner.NO_QR_CODE_FOUND) return;\n        console.log(error);\n    }\n\n    _getCameraStream(facingMode, exact = false) {\n        const constraintsToTry = [{\n            width: { min: 1024 }\n        }, {\n            width: { min: 768 }\n        }, {}];\n\n        if (facingMode) {\n            if (exact) {\n                facingMode = { exact: facingMode };\n            }\n            constraintsToTry.forEach(constraint => constraint.facingMode = facingMode);\n        }\n        return this._getMatchingCameraStream(constraintsToTry);\n    }\n\n    _getMatchingCameraStream(constraintsToTry) {\n        if (!navigator.mediaDevices || constraintsToTry.length === 0) {\n            return Promise.reject('Camera not found.');\n        }\n        return navigator.mediaDevices.getUserMedia({\n            video: constraintsToTry.shift()\n        }).catch(() => this._getMatchingCameraStream(constraintsToTry));\n    }\n\n    /* async */\n    _setFlash(on) {\n        return this.hasFlash().then((hasFlash) => {\n            if (!hasFlash) return Promise.reject('No flash available');\n            // Note that the video track is guaranteed to exist at this point\n            return this.$video.srcObject.getVideoTracks()[0].applyConstraints({\n                advanced: [{ torch: on }],\n            });\n        }).then(() => this._flashOn = on);\n    }\n\n    _setVideoMirror(facingMode) {\n        // in user facing mode mirror the video to make it easier for the user to position the QR code\n        const scaleFactor = facingMode==='user'? -1 : 1;\n        this.$video.style.transform = 'scaleX(' + scaleFactor + ')';\n    }\n\n    _getFacingMode(videoStream) {\n        const videoTrack = videoStream.getVideoTracks()[0];\n        if (!videoTrack) return null; // unknown\n        // inspired by https://github.com/JodusNodus/react-qr-reader/blob/master/src/getDeviceId.js#L13\n        return /rear|back|environment/i.test(videoTrack.label)\n            ? 'environment'\n            : /front|user|face/i.test(videoTrack.label)\n                ? 'user'\n                : null; // unknown\n    }\n\n    static _drawToCanvas(image, sourceRect=null, canvas=null, fixedCanvasSize=false) {\n        canvas = canvas || document.createElement('canvas');\n        const sourceRectX = sourceRect && sourceRect.x? sourceRect.x : 0;\n        const sourceRectY = sourceRect && sourceRect.y? sourceRect.y : 0;\n        const sourceRectWidth = sourceRect && sourceRect.width? sourceRect.width : image.width || image.videoWidth;\n        const sourceRectHeight = sourceRect && sourceRect.height? sourceRect.height : image.height || image.videoHeight;\n        if (!fixedCanvasSize && (canvas.width !== sourceRectWidth || canvas.height !== sourceRectHeight)) {\n            canvas.width = sourceRectWidth;\n            canvas.height = sourceRectHeight;\n        }\n        const context = canvas.getContext('2d', { alpha: false });\n        context.imageSmoothingEnabled = false; // gives less blurry images\n        context.drawImage(image, sourceRectX, sourceRectY, sourceRectWidth, sourceRectHeight, 0, 0, canvas.width, canvas.height);\n        return [canvas, context];\n    }\n\n    /* async */\n    static _loadImage(imageOrFileOrBlobOrUrl) {\n        if (imageOrFileOrBlobOrUrl instanceof HTMLCanvasElement || imageOrFileOrBlobOrUrl instanceof HTMLVideoElement\n            || window.ImageBitmap && imageOrFileOrBlobOrUrl instanceof window.ImageBitmap\n            || window.OffscreenCanvas && imageOrFileOrBlobOrUrl instanceof window.OffscreenCanvas) {\n            return Promise.resolve(imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof Image) {\n            return QrScanner._awaitImageLoad(imageOrFileOrBlobOrUrl).then(() => imageOrFileOrBlobOrUrl);\n        } else if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob\n            || imageOrFileOrBlobOrUrl instanceof URL || typeof(imageOrFileOrBlobOrUrl)==='string') {\n            const image = new Image();\n            if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                image.src = URL.createObjectURL(imageOrFileOrBlobOrUrl);\n            } else {\n                image.src = imageOrFileOrBlobOrUrl;\n            }\n            return QrScanner._awaitImageLoad(image).then(() => {\n                if (imageOrFileOrBlobOrUrl instanceof File || imageOrFileOrBlobOrUrl instanceof Blob) {\n                    URL.revokeObjectURL(image.src);\n                }\n                return image;\n            });\n        } else {\n            return Promise.reject('Unsupported image type.');\n        }\n    }\n\n    /* async */\n    static _awaitImageLoad(image) {\n        return new Promise((resolve, reject) => {\n            if (image.complete && image.naturalWidth!==0) {\n                // already loaded\n                resolve();\n            } else {\n                let onLoad, onError;\n                onLoad = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    resolve();\n                };\n                onError = () => {\n                    image.removeEventListener('load', onLoad);\n                    image.removeEventListener('error', onError);\n                    reject('Image load error');\n                };\n                image.addEventListener('load', onLoad);\n                image.addEventListener('error', onError);\n            }\n        });\n    }\n\n    /* async */\n    static _postWorkerMessage(qrEngineOrQrEnginePromise, type, data) {\n        return Promise.resolve(qrEngineOrQrEnginePromise).then((qrEngine) => {\n            if (!(qrEngine instanceof Worker)) return;\n            qrEngine.postMessage({ type, data });\n        });\n    }\n}\nQrScanner.DEFAULT_CANVAS_SIZE = 400;\nQrScanner.NO_QR_CODE_FOUND = 'No QR code found';\nQrScanner.WORKER_PATH = 'qr-scanner-worker.min.js';\n","import unsupportedIterableToArray from \"./unsupportedIterableToArray\";\nexport default function _createForOfIteratorHelper(o) {\n  if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) {\n    if (Array.isArray(o) || (o = unsupportedIterableToArray(o))) {\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var it,\n      normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = o[Symbol.iterator]();\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}","import React, { useEffect, useRef, useState } from \"react\";\nimport styled, { keyframes } from \"styled-components\";\nimport { FontAwesomeIcon } from \"@fortawesome/react-fontawesome\";\n\nimport { faHeart, faQrcode, faStore } from \"@fortawesome/free-solid-svg-icons\";\nimport { Link } from \"react-router-dom\";\n\nimport SmartphoneFrame from \"../Smartphone_Frame.svg\";\nimport MobileApp from \"../MobileApp.png\";\nimport LandingPreview from \"../PreviewLanding.svg\";\nimport QrScanner from \"qr-scanner\";\n\nconst ScaleUp = keyframes`\n  from {\n    transform: scale(0.5);\n  }\n  to {\n    transform: scale(1);\n  }\n  `;\n\nconst ContainerStyled = styled.div`\n  width: 100%;\n  height: 100%;\n  background-color: #232323;\n  color: white;\n  display: grid;\n  grid-template-rows: 3.5fr 1fr auto;\n  font-size: calc(1vw + 1vh + 5px);\n`;\n\nconst Footer = styled.div`\n  background-color: white;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  box-shadow: -3px 0px 50px 5px black;\n  color: black;\n  // flex-direction: column;\n`;\n\nconst About = styled.div`\n  padding: 15px 10px;\n  font-size: 0.8em;\n\n  a {\n    text-decoration: none;\n    color: white;\n  }\n`;\n\nconst Button = styled.button`\n  border: none;\n  color: white;\n  padding: 10px 15px;\n  font-size: 1em;\n  background-color: ${(props) => props.color[0]};\n  border-radius: 3px;\n  transition: all 0.2s;\n  margin: 10px;\n  animation: ${ScaleUp} 0.3s;\n\n  &:hover {\n    background-color: ${(props) => props.color[1]};\n    transition: all 0.2s;\n    transform: translateY(-10px);\n    cursor: pointer;\n  }\n`;\n\nconst PromotionContainer = styled.div`\n  display: grid;\n  grid-template-columns: 1fr;\n  grid-template-rows: [title-start] 25% [title-end preview-start] 1fr [preview-end];\n  justify-items: center;\n  align-items: center;\n  height: 100%;\n\n  @media only screen and (max-width: 800px) {\n    grid-template-rows: [title-start] 25% [title-end preview-start] 1fr [preview-end];\n  }\n\n  overflow: hidden;\n`;\n\nconst Detail = styled.span`\n  font-size: calc(1vw + 2vh);\n\n  @media only screen and (max-width: 800px) {\n    font-size: calc(1vw + 3vh);\n  }\n`;\n\nconst Title = styled.span`\n  font-size: 1.5em;\n  font-weight: bold;\n`;\n\nconst LandingImg = styled.img`\n  height: 100%;\n  width: 100%;\n`;\n\nconst SmallText = styled.span`\n  font-size: 0.5em;\n  color: red;\n  position: absolute;\n  left: 50%;\n  white-space: nowrap;\n  transform: translate(-50%);\n`;\n\nfunction Container() {\n  const videoRef = useRef();\n  const [scanner, scannerSet] = useState();\n  const [scanning, scanningSet] = useState(false);\n\n  useEffect(() => {\n    if (scanning) {\n      let sc = new QrScanner(\n        videoRef.current,\n        (result) => (window.location.href = result)\n      );\n      // scannerSet(sc);\n      sc.start();\n      return () => {\n        sc.stop();\n        sc.destroy();\n        sc = null;\n      };\n    }\n  }, [scanning, scanner]);\n\n  function StartScan() {\n    scanningSet(!scanning);\n  }\n\n  return (\n    <ContainerStyled>\n      <PromotionContainer>\n        {!scanning ? (\n          <>\n            <Detail>\n              <Title>FoodHub</Title>\n              <br />\n              แพลตฟอร์มสำหรับร้านอาหาร\n            </Detail>\n\n            <LandingImg src={LandingPreview} alt=\"Preview\" />\n          </>\n        ) : (\n          <video\n            style={{ gridRow: \"1 / 3\", width: \"100%\" }}\n            ref={videoRef}\n          ></video>\n        )}\n      </PromotionContainer>\n      <Footer>\n        {/* <span style={{ fontSize: \"0.9em\" }}> */}\n        {/*   {/1* <FontAwesomeIcon icon={faQrcode} /> สแกนเพื่อเริ่มสั่งเลย *1/} */}\n        {/*   เริ่มใช้งานเลย */}\n        {/* </span> */}\n        <div style={{ position: \"relative\" }}>\n          <Button onClick={StartScan} color={[\"#555555\", \"#555555\"]} disabled>\n            <FontAwesomeIcon icon={faQrcode} /> สแกนเพื่อสั่ง\n          </Button>\n          <br />\n          <SmallText>ปิดการใช้งานชั่วคราว</SmallText>\n        </div>\n        <span style={{ color: \"#555555\", fontSize: \"0.8em\" }}>\n          {\" \"}\n          | เริ่มใช้งานเลย |{\" \"}\n        </span>\n        <Link to=\"/manager/sign-in\">\n          <Button color={[\"#232323\", \"#555555\"]}>\n            <FontAwesomeIcon icon={faStore} /> สร้างร้านอาหาร\n          </Button>\n        </Link>\n      </Footer>\n      <About>\n        <span>\n          Made with <FontAwesomeIcon icon={faHeart} style={{ color: \"red\" }} />{\" \"}\n          by\n        </span>{\" \"}\n        <a target=\"_blank\" href=\"https://github.com/gitguddev\">\n          GitGud Dev\n        </a>\n      </About>\n    </ContainerStyled>\n  );\n}\n\nfunction Landing() {\n  return <Container />;\n}\n\nexport default Landing;\n"],"sourceRoot":""}